#!/usr/bin/perl -w

# (C) 2005 Dr. Thomas Fischbacher
# Generate petsc_error.mli, petsc_error.ml, petsc_error.c
# from $(PETSCDIR)/include/petscerror.h

use Data::Dumper;
my $petscdir="$ARGV[0]";
my $petscerror_h="$petscdir/petscerror.h";

my $contents_petscerror_h=`/bin/cat $petscerror_h`;


# Let's play preprocessor for the preprocessor:
$contents_petscerror_h=~s#\Q/*\E(.*?)\Q*/\E# #g; # kill C comments

# XXX Note: there are duplicate values in petscerror.h
# These confuse our mapping, hence we have to throw them out.
# (Not a good solution, but not a too bad one, either!)

my %seen_petsc_errors;

my @petsc_errors=
  map {m/#define\s+(PETSC_ERR_\S+)\s+(\d+)/?[$1,$2]:()}
  (split /\n/, $contents_petscerror_h);

unshift @petsc_errors, ["PETSC_ERR_NONE",0];

# print Dumper(\@petsc_errors);;

my @ocaml_code_mli=
(qq^
(* (C) 2005 Dr. Thomas Fischbacher
     This file is machine generated by petsc_error.pl - do not edit!
 *)

type petsc_error =
^);

my @c_code=
(qq[
/* (C) 2005 Dr. Thomas Fischbacher
   This file is machine generated by petsc_error.pl - do not edit!

   to be compiled with:

    mpicc -I $petscdir/include -c -o petsc_error.o petsc_error.c
*/

#include "petsc.h"

#define PETSC_ERR_NONE 0
/* ^ This is missing in the Petsc 2.2.0 sources! */

int _caml_petsc_error_nr_to_caml(int nr)
{
  switch(nr)
   {
]);

my $err_nr=0;

for my $pe (@petsc_errors)
  {
    my($name,$code)=@$pe;

    # First, kill duplicates:
    next if $seen_petsc_errors{$code};
    $seen_petsc_errors{$code}=1;

    $name=~/PETSC_ERR_(.*)/ or next;
    my $xname = lc $1;
    push @ocaml_code_mli, " | Petsc_error_$xname\n";


    push @c_code,
qq^     case $name:
       return $err_nr;
^;
    $err_nr++;
  }

push @c_code, 
qq^    default:
       return $err_nr;
   }
}
^;


push @c_code, 
qq^

int _caml_petsc_error_nr_from_caml(int nr)
{
  switch(nr)
   {
^;

$err_nr=0;
%seen_petsc_errors=();

for my $pe (@petsc_errors)
  {
    my($name,$code)=@$pe;

    # First, kill duplicates:
    next if $seen_petsc_errors{$code};
    $seen_petsc_errors{$code}=1;

    push @c_code,
qq^     case $err_nr:
       return $name;
^;
    $err_nr++;
  }


push @c_code, 
qq^    default:
       return $err_nr;
   }
}
^;



push @ocaml_code_mli, " | Petsc_error_UNKNOWN\n\n";

push @ocaml_code_mli, 
qq^
exception Petsc_exn of (petsc_error * int * string)
(*
   Note that this is a pretty bad tripwire.
   The parens are actually very important here!

   This would mean something entirely different:

   exception Petsc_exn of petsc_error * int * string

   See this thread:
   http://caml.inria.fr/pub/ml-archives/caml-list/2005/07/9b5f42a4ee3db5aa241fdf39d002ef90.en.html
*)

exception Petsc_caml_interface_exn of string
^;


my @ocaml_code_ml=(@ocaml_code_mli,
qq^
let _ =
 begin
  Callback.register_exception "ocaml_exn_petsc" (Petsc_exn (Petsc_error_UNKNOWN,0,""));
  Callback.register_exception "ocaml_exn_petsc_caml_interface" (Petsc_caml_interface_exn "");
 end
;;

^);

open ERR_MLI, ">petsc_error.mli" or die "open: $!\n";
printf ERR_MLI "%s",(join "",@ocaml_code_mli);
close ERR_MLI;

open ERR_MLI, ">petsc_error.ml" or die "open: $!\n";
printf ERR_MLI "%s",(join "",@ocaml_code_ml);
close ERR_MLI;


open ERR_C, ">petsc_error.c" or die "open: $!\n";
printf ERR_C "%s",(join "",@c_code);
close ERR_C;
