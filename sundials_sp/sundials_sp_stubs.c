/* (C) 2006 Dr. Thomas Fischbacher
   SUNDIALS interface
 */

/* A CVODE pill will have to contain:

  A C-tuple holding:
   - the abstract cvode
   - The petsc vector's data (so that we can VecRestoreArray when we no longer need it)
   - The N_Vector (for N_VDestroy_Serial)
   - a pointer to C memory holding some ml GC roots, containing
      * a tuple of callback functions holding
          - the RHS callback
          - the preconditioner_setup callback
          - the preconditioner_solver callback
          - the jacobi_times_vector callback or Val_unit
      * initially, a 4-tuple ((),(),(),())
      (whose entries later on will automatically be filled
       with the callback-function args tuples)
      * the ml-wrapped petsc vector (needed for VecRestoreArray)

   Note: we also should provide a "destroy" function on cvodes so that we can
   invalidate them explicitly.

   XXX NOTE: I am using petsc here, so I really would like to check
   petsc for being initialized, and the vector data structure for
   being valid. However, these check functions are internal to the
   petsc module... So, for now, we do not do that. Not much harm done.

   XXX NOTE: what if a callback function raises an exception?
   This may severely mess up internal de-allocation routines,
   hence we should see that we do catch all exceptions from callbacks.
   TODO TODO TODO!


   NOTE: we would like to make the sundials module a non-intrusive
   add-on, in such a way that someone who does not intend to use
   libsundials functions or features should not have to worry about
   installing the library in order to work with our code. We can
   indeed achieve this through dynamic linking techniques.

   However, there is an issue with sundials-specific definitions: in
   order to also get rid of the build-dependency on libsundials
   includes, we have to copy the relevant pieces into an own header
   file, and keep this in sync with libsundials updates. That is the
   price we eventually have to pay, but I suppose it is worth it.

   Note that we need dynamic linking capabilities anyway (for the
   fastfields mechanism), so we are not creating any new dependencies.

 */


#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/misc.h>
#include <caml/mlvalues.h>

#include <mpi.h>

#include "camlmpi.h"

#include <caml/bigarray.h>

#include <unistd.h>
#include <stdio.h>
#include <float.h>

#include <dlfcn.h>

#include "sundials_sp_stubs.h"

#include "petsc.h"
#include "petscvec.h"
#include "petscsys.h"

#define Store_c_field(block,offset,x) (Field(block,offset)=(value)x)

static char *err_exn_name="ocaml_exn_sundials_sp_caml_interface";

static int sundials_sp_is_initialized=0;
static void *libsundials_nvec_serial;
static void *libsundials_nvec_parallel;
static void *libsundials_cvode;

/* Here we include the file with the definitions of the needed Sundials
 * functions: this is mostly automatically generated by the file
 * extract_from_header.py. Whenever a functions has to be added, just
 * open this file, add the function to the list of functions
 * and re-run the script. Check that the new version sundials_fntable.c
 * make sense and compile!
 */
#include "sundials_fntable.c"

static void own_raise_with_string(value x, char *s)
{
  /* fprintf(stderr,"SUNDIALS-SP Exception: '%s'\n",s);fflush(stderr); / * DDD */

  raise_with_string(*caml_named_value(err_exn_name),s);
}

/** Loads symbols from the sundials libraries.
 * If an error occours, returns a string with the name of the symbol
 * which caused the failure, otherwise returns (char *) 0
 */
static char *init_sundials(char *path_nvecserial,
			   char *path_nvecparallel,
			   char *path_cvode)
{
  SundialsFnTable *symbol_item;
  if(sundials_sp_is_initialized) return (char *) 0;

#if 0
  fprintf(stderr,"DDD SUNDIALS-SP Init: '%s' '%s' '%s'\n",path_nvecserial,path_nvecparallel,path_cvode);fflush(stderr); /* DDD */
#endif


  libsundials_nvec_serial = dlopen(path_nvecserial, RTLD_NOW);

  if(libsundials_nvec_serial == (void *) 0) {
    return "cannot dlopen() libsundials_nvecserial!";
  }


  libsundials_nvec_parallel = dlopen(path_nvecparallel, RTLD_NOW);

  if(libsundials_nvec_parallel == (void *) 0)
    {
      (void) dlclose(libsundials_nvec_serial);
      return "cannot dlopen() libsundials_nvecparallel!";
    }

  libsundials_cvode = dlopen(path_cvode, RTLD_NOW);

  if(libsundials_cvode == (void *) 0) {

    (void) dlclose(libsundials_nvec_parallel);
    return "cannot open sundials-cvode with dlopen()";
  }

  for(symbol_item = &symbols_table[0];
      symbol_item->target != (void **) 0;
      symbol_item++) {


    *symbol_item->target = dlsym(*symbol_item->library, symbol_item->sym_name);
    if (*symbol_item->target == (void *) 0) {
      dlclose(libsundials_cvode);
      dlclose(libsundials_nvec_serial);
      dlclose(libsundials_nvec_parallel);
      return symbol_item->sym_name;
    }


  }

  sundials_sp_is_initialized=1;

#if 0
  fprintf(stderr,"DDD SUNDIALS-SP sundials_sp_is_initialized=%d\n",sundials_sp_is_initialized); /* DDD */
#endif

  return (char *) 0;
}

static void sundials_sp_checkinit(void)
{
  if(!sundials_sp_is_initialized)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "libsundials was not initialized!");
    }
}

CAMLprim value caml_sundials_sp_init(value ml_sundials_path_nvec_serial,
				     value ml_sundials_path_nvec_parallel,
				     value ml_sundials_path_cvode)
{
  CAMLparam3(ml_sundials_path_nvec_serial,
	     ml_sundials_path_nvec_parallel,
	     ml_sundials_path_cvode);

  char *err_src;

  err_src = init_sundials(String_val(ml_sundials_path_nvec_serial),
			  String_val(ml_sundials_path_nvec_parallel),
                          String_val(ml_sundials_path_cvode));

  if (err_src == (char *) 0) {
    CAMLreturn(Val_unit);

  } else {
    static char msg[512];
    (void) snprintf(msg, 512, "libsundials initialization failure: %-.128s", err_src);
    own_raise_with_string(*caml_named_value(err_exn_name), msg);
    /* Never reached, but important to keep GCC happy (w.r.t. warnings) */
    CAMLreturn(Val_unit);
  }
}


static void aiee(char *msg)
{
  fprintf(stderr,"AIEE - FATAL FAILURE: %s\n",msg);
  exit(1);
}

static void finalize_cvode(value block)
{
  void *cvode;
  PetscScalar *petsc_data;
  N_Vector nvec;
  value *root_cells;
  Vec petsc_vec;

  cvode=(void *)Field(block,1);

  if(cvode!=0)
    {
      nvec=(N_Vector)Field(block,3);
      petsc_vec=(Vec)Field(block,4);
      petsc_data=(PetscScalar *)Field(block,5);
      root_cells=(value *)Field(block,6);
      /* fprintf(stderr,"Finalizing cvode 0x%08x\n",cvode);fflush(stderr); */

      /* mf: I comment this line and replace it with the parallel equivalent: this is a cut and paste work, please RECHECK IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
#ifdef Destroy_Serial
      dyn_N_VDestroy_Serial(nvec);
#else
      dyn_N_VDestroy_Parallel(nvec);
#endif

      if(petsc_vec)
	/* This is not just defensive coding,
	   this also allows us to create a cvode not
	   from a petsc initial vector, but from something
	   else - if we set the petsc_vec field to 0 then!
	*/
	{
	  VecRestoreArray(petsc_vec,&petsc_data);
	}

      caml_remove_global_root(&root_cells[0]);
      caml_remove_global_root(&root_cells[1]);
      caml_remove_global_root(&root_cells[2]);
      caml_remove_global_root(&root_cells[3]);

      dyn_CVodeFree(&cvode);
      /* It's strange that we pass an address here,
	 but that is what the CVode examples say... */
    }
}

/* XXX p.38[48] cvodesetfdata, p.61[71] CVRhsFn */

/*
   callback_data is a memory block containing two OCaml registered global roots.
   First one holds the callback function, the second one a tuple which we use
   to assemble the arguments for the callback.
*/

static int rhs_fn_wrapper(realtype time,
			  N_Vector y,
			  N_Vector ydot,
			  void *callback_data)
{
  CAMLparam0();	/* We need this because we use ml heap-allocations */

  value *callback_ml=(value *)callback_data;
  realtype *y_data, *ydot_data;
  long local_size[1];
  int is_parallel;

  CAMLlocal5(callback_fun,callback_args,callback_return,ba_y,ba_ydot);

  /* fprintf(stderr,"DDD Sundials-SP: rhs_fn_wrapper #1\n");fflush(stderr); */

  callback_fun=Field(callback_ml[0],0);
  callback_args=Field(callback_ml[1],0);
  is_parallel=Bool_val(Field(callback_ml[0],4));

  /* fprintf(stderr,"DDD Sundials-SP: rhs_fn_wrapper #2\n");fflush(stderr); */

  if(callback_fun==Val_unit)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"No Callback function registered!");
    }

  if(callback_args==Val_unit)
    {
      /* We have not used that callback before... initialize the argument tuple. */
      callback_args = alloc_tuple(3);
      Store_field(callback_args,0,Val_unit);
      Store_field(callback_args,1,Val_unit);
      Store_field(callback_args,2,Val_unit);
      Store_field(callback_ml[1],0,callback_args);
    }

  if(is_parallel)
    {
      y_data=NV_DATA_P(y);
      ydot_data=NV_DATA_P(ydot);
      local_size[0]=NV_LOCLENGTH_P(y);
    }
  else
    {
      y_data=NV_DATA_S(y);
      ydot_data=NV_DATA_S(ydot);
      local_size[0]=NV_LENGTH_S(y);
    }

  ba_y=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      /* XXX NOTE: THIS RELIES ON realtype == double! */
		      1, y_data, local_size);

  ba_ydot=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			 /* XXX NOTE: THIS RELIES ON realtype == double! */
			 1, ydot_data, local_size);

  Store_field(callback_args,0,copy_double(time));
  Store_field(callback_args,1,ba_y);
  Store_field(callback_args,2,ba_ydot);

  /* callback_return=caml_callback(callback,callback_args);
     For strange reasons, this did not compile... */

  /*fprintf(stderr,"SSPI t=%6.4f y=%6.4f %6.4f %6.4f ... ydot=%6.4f %6.4f %6.4f ...\n",
	    time,
	    y_data[0],y_data[1],y_data[2],
	    ydot_data[0],ydot_data[1],ydot_data[2]);
  */

  callback_return=caml_callback2(callback_fun,callback_args,Val_unit);

  /*
  fprintf(stderr,"SSPO t=%6.4f y=%6.4f %6.4f %6.4f ... ydot=%6.4f %6.4f %6.4f ...\n",
	  time,
	  y_data[0],y_data[1],y_data[2],
	  ydot_data[0],ydot_data[1],ydot_data[2]);
  fflush(stderr);
  */

  Store_field(callback_args,1,Val_unit);
  Store_field(callback_args,2,Val_unit);
  /* This ensures our bigarrays can be GC'd. */

  CAMLreturn(Int_val(callback_return));
}

static int preconditioner_setup_wrapper(realtype t, N_Vector y, N_Vector fy,
					booleantype j_ok, booleantype *jcurPtr,
					realtype gamma, void *callback_data,
					N_Vector tmp1, N_Vector tmp2,
					N_Vector tmp3)
{
  CAMLparam0();	/* We need this because we use ml heap-allocations */

  value *callback_ml=(value *)callback_data;
  realtype *y_data, *fy_data, *tmp1_data, *tmp2_data,*tmp3_data;
  int i;
  long local_size[1];
  int is_parallel;

  CAMLlocal3(callback_fun,callback_args,callback_return);
  CAMLlocal5(ba_y,ba_fy,ba_tmp1,ba_tmp2,ba_tmp3);

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #1\n");fflush(stderr); */

  callback_fun=Field(callback_ml[0],1);
  callback_args=Field(callback_ml[1],1);
  is_parallel=Bool_val(Field(callback_ml[0],4));

  if(callback_fun==Val_unit)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"No Callback function registered!");
    }

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #2\n");fflush(stderr); */

  if(callback_args==Val_unit)
    {
      /* We have not used that callback before... initialize the argument tuple. */
      callback_args = alloc_tuple(8);
      for(i=0;i<8;i++)Store_field(callback_args,i,Val_unit);
      Store_field(callback_ml[1],1,callback_args);
    }

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #3\n");fflush(stderr); */

  if(is_parallel)
    {
      y_data=NV_DATA_P(y);
      fy_data=NV_DATA_P(fy);
      tmp1_data=NV_DATA_P(tmp1);
      tmp2_data=NV_DATA_P(tmp2);
      tmp3_data=NV_DATA_P(tmp3);
      local_size[0]=NV_LOCLENGTH_P(y);
    }
  else
    {
      y_data=NV_DATA_S(y);
      fy_data=NV_DATA_S(fy);
      tmp1_data=NV_DATA_S(tmp1);
      tmp2_data=NV_DATA_S(tmp2);
      tmp3_data=NV_DATA_S(tmp3);
      local_size[0]=NV_LENGTH_S(y);
    }

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #4\n");fflush(stderr); */

  ba_y=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      /* XXX NOTE: THIS RELIES ON realtype == double! */
		      1, y_data, local_size);

  ba_fy=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		       1, fy_data, local_size);

  ba_tmp1=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			 1, tmp1_data, local_size);

  ba_tmp2=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			 1, tmp2_data, local_size);

  ba_tmp3=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			 1, tmp3_data, local_size);

  /* callback_args will be type-ordered:
     (j_ok, t,gamma, y,fy,tmp1,tmp2,tmp3)

     Expected result: (j_current:bool,result:int)
  */

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #5\n");fflush(stderr); */

  Store_field(callback_args,0,Val_bool(j_ok?1:0));
  Store_field(callback_args,1,copy_double(t));
  Store_field(callback_args,2,copy_double(gamma));
  Store_field(callback_args,3,ba_y);
  Store_field(callback_args,4,ba_fy);
  Store_field(callback_args,5,ba_tmp1);
  Store_field(callback_args,6,ba_tmp2);
  Store_field(callback_args,7,ba_tmp3);

  /* callback_return=caml_callback(callback,callback_args);
     For strange reasons, this did not compile... */

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #6\n");fflush(stderr); */

  callback_return=caml_callback2(callback_fun,callback_args,Val_unit);

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #7\n");fflush(stderr); */

  Store_field(callback_args,3,Val_unit);
  Store_field(callback_args,4,Val_unit);
  Store_field(callback_args,5,Val_unit);
  Store_field(callback_args,6,Val_unit);
  Store_field(callback_args,7,Val_unit);
  /* This ensures our bigarrays can be GC'd. */

  /* fprintf(stderr,"DDD Sundials-SP: pc_setup_wrapper #8\n");fflush(stderr); */

  *jcurPtr=(Val_bool(Field(callback_return,0))?TRUE:FALSE);

  CAMLreturn(Int_val(Field(callback_return,1)));
  /* return 0 => success
     positive => recoverable
     negative => unrecoverable error
  */
}

static int preconditioner_solve_wrapper(realtype t, N_Vector y, N_Vector fy,
					N_Vector r, N_Vector z,
					realtype gamma, realtype delta,
					int lr, void *callback_data, N_Vector tmp)
{
  CAMLparam0();	/* We need this because we use ml heap-allocations */

  value *callback_ml=(value *)callback_data;
  realtype *y_data, *fy_data, *r_data, *z_data,*tmp_data;
  int i;
  long local_size[1];
  int is_parallel;

  CAMLlocal3(callback_fun,callback_args,callback_return);
  CAMLlocal5(ba_y,ba_fy,ba_r,ba_z,ba_tmp);

  /* fprintf(stderr,"DDD Sundials-SP: pc_solve_wrapper\n");fflush(stderr); */

  callback_fun=Field(callback_ml[0],2);
  callback_args=Field(callback_ml[1],2);
  is_parallel=Bool_val(Field(callback_ml[0],4));

  if(callback_fun==Val_unit)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"No Callback function registered!");
    }

  if(callback_args==Val_unit)
    {
      /* We have not used that callback before... initialize the argument tuple. */
      callback_args = alloc_tuple(9);
      for(i=0;i<9;i++)Store_field(callback_args,i,Val_unit);
      Store_field(callback_ml[1],2,callback_args);
    }

  if(is_parallel)
    {
      y_data=NV_DATA_P(y);
      fy_data=NV_DATA_P(fy);
      r_data=NV_DATA_P(r);
      z_data=NV_DATA_P(z);
      tmp_data=NV_DATA_P(tmp);
      local_size[0]=NV_LOCLENGTH_P(y);
    }
  else
    {
      y_data=NV_DATA_S(y);
      fy_data=NV_DATA_S(fy);
      r_data=NV_DATA_S(r);
      z_data=NV_DATA_S(z);
      tmp_data=NV_DATA_S(tmp);
      local_size[0]=NV_LENGTH_S(y);
    }

  ba_y=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      /* XXX NOTE: THIS RELIES ON realtype == double! */
		      1, y_data, local_size);

  ba_fy=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		       1, fy_data, local_size);

  ba_r=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      1, r_data, local_size);

  ba_z=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      1, z_data, local_size);

  ba_tmp=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			1, tmp_data, local_size);

  /* callback_args will be type-ordered:
     (lr, t,gamma,delta, y,fy,r,z,tmp)
  */

  Store_field(callback_args,0,Val_int(lr));
  Store_field(callback_args,1,copy_double(t));
  Store_field(callback_args,2,copy_double(gamma));
  Store_field(callback_args,3,copy_double(delta));
  Store_field(callback_args,4,ba_y);
  Store_field(callback_args,5,ba_fy);
  Store_field(callback_args,6,ba_r);
  Store_field(callback_args,7,ba_z);
  Store_field(callback_args,8,ba_tmp);

  /* callback_return=caml_callback(callback_fun,callback_args);
     For strange reasons, this did not compile... */

  callback_return=caml_callback2(callback_fun,callback_args,Val_unit);

  Store_field(callback_args,4,Val_unit);
  Store_field(callback_args,5,Val_unit);
  Store_field(callback_args,6,Val_unit);
  Store_field(callback_args,7,Val_unit);
  Store_field(callback_args,8,Val_unit);
  /* This ensures our bigarrays can be GC'd. */

  CAMLreturn(Int_val(callback_return));
  /* return 0 => success
     positive => recoverable
     negative => unrecoverable error
  */
}




static int jacobian_times_vector_wrapper(N_Vector v, N_Vector Jv,
					 realtype t, N_Vector y, N_Vector fy,
					 void *callback_data, N_Vector tmp)
{
  CAMLparam0();	/* We need this because we use ml heap-allocations */

  value *callback_ml=(value *)callback_data;
  realtype *v_data, *Jv_data, *y_data, *fy_data,*tmp_data;
  int i;
  long local_size[1];
  int is_parallel;

  CAMLlocal3(callback_fun,callback_args,callback_return);
  CAMLlocal5(ba_v,ba_Jv,ba_y,ba_fy,ba_tmp);

  /* fprintf(stderr,"DDD Sundials-SP: J*V_wrapper\n");fflush(stderr); */

  callback_fun=Field(callback_ml[0],3);
  callback_args=Field(callback_ml[1],3);
  is_parallel=Bool_val(Field(callback_ml[0],4));

  if(callback_fun==Val_unit)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"No Callback function registered!");
    }

  if(callback_args==Val_unit)
    {
      /* We have not used that callback before... initialize the argument tuple. */
      callback_args = alloc_tuple(6);
      for(i=0;i<6;i++)Store_field(callback_args,i,Val_unit);
      Store_field(callback_ml[1],3,callback_args);
    }

  if(is_parallel)
    {
      v_data=NV_DATA_P(v);
      Jv_data=NV_DATA_P(Jv);
      y_data=NV_DATA_P(y);
      fy_data=NV_DATA_P(fy);
      tmp_data=NV_DATA_P(tmp);

      local_size[0]=NV_LOCLENGTH_P(y);
    }
  else
    {
      v_data=NV_DATA_S(v);
      Jv_data=NV_DATA_S(Jv);
      y_data=NV_DATA_S(y);
      fy_data=NV_DATA_S(fy);
      tmp_data=NV_DATA_S(tmp);

      local_size[0]=NV_LENGTH_S(y);
    }

  ba_v=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      /* XXX NOTE: THIS RELIES ON realtype == double! */
		      1, v_data, local_size);

  ba_Jv=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		       1, Jv_data, local_size);


  ba_y=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		      1, y_data, local_size);

  ba_fy=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
		       1, fy_data, local_size);

  ba_tmp=alloc_bigarray(BIGARRAY_FLOAT64 | BIGARRAY_C_LAYOUT,
			1, tmp_data, local_size);

  /* callback_args will be type-ordered:
     (t,v,Jv,y,fy,tmp)
  */

  Store_field(callback_args,0,copy_double(t));
  Store_field(callback_args,1,ba_v);
  Store_field(callback_args,2,ba_Jv);
  Store_field(callback_args,3,ba_y);
  Store_field(callback_args,4,ba_fy);
  Store_field(callback_args,5,ba_tmp);

  /* callback_return=caml_callback(callback_fun,callback_args);
     For strange reasons, this did not compile... */

  callback_return=caml_callback2(callback_fun,callback_args,Val_unit);

  Store_field(callback_args,1,Val_unit);
  Store_field(callback_args,2,Val_unit);
  Store_field(callback_args,3,Val_unit);
  Store_field(callback_args,4,Val_unit);
  Store_field(callback_args,5,Val_unit);
  /* This ensures our bigarrays can be GC'd. */

  CAMLreturn(Int_val(callback_return));
  /* return 0 => success
     other => unrecoverable error
  */
}

/* We use this to return a value which has proper type cvode,
   but otherwise is invalid. */
CAMLprim value caml_sundials_sp_cvode_make_dummy(value ml_unit)
{
  CAMLparam1(ml_unit);

  CAMLlocal1(cvode_block);

  cvode_block = alloc_final(7, finalize_cvode, sizeof(void*),sizeof(void*));

  Store_c_field(cvode_block, 1,0);
  Store_c_field(cvode_block, 2,0);
  Store_c_field(cvode_block, 3,0);
  Store_c_field(cvode_block, 4,0);
  Store_c_field(cvode_block, 5,0);
  Store_c_field(cvode_block, 6,0);

  CAMLreturn(cvode_block);
}

CAMLprim value caml_sundials_sp_cvode_make_raw_ba(value ml_args)
{
  void *cvode;
  int flag,flag2,is_parallel,i;
  realtype rel_tol,abs_tol;
  value *root_cells;
  N_Vector nvec_initial_config;
  MPI_Comm comm;

  CAMLparam1(ml_args);
  CAMLlocal3(ml_comm,ml_ba_initial_global_length,ml_is_parallel);
  CAMLlocal5(ml_fun_rhs,ml_ba_initial_data,
	     ml_initial_time,ml_rel_tol,ml_abs_tol);

  /* fprintf(stderr,"Sundials-SP: making CVODE #1!\n");fflush(stderr); */

  ml_comm=Field(ml_args,0);
  ml_is_parallel=Field(ml_args,1);
  ml_fun_rhs=Field(ml_args,2);
  ml_ba_initial_global_length=Field(ml_args,3);
  ml_ba_initial_data=Field(ml_args,4);
  ml_initial_time=Field(ml_args,5);
  ml_rel_tol=Field(ml_args,6);
  ml_abs_tol=Field(ml_args,7);

  comm=Comm_val(ml_comm);
  is_parallel=Bool_val(ml_is_parallel);

  /* fprintf(stderr,"Sundials-SP: making CVODE #2! init=%d\n",sundials_sp_is_initialized);fflush(stderr); */

  sundials_sp_checkinit();

  /* fprintf(stderr,"Sundials-SP: making CVODE #3!\n");fflush(stderr); */

  rel_tol=Double_val(ml_rel_tol);
  abs_tol=Double_val(ml_abs_tol);

  if(is_parallel)
    {
      nvec_initial_config=dyn_N_VMake_Parallel(comm,
					       Bigarray_val(ml_ba_initial_data)->dim[0],
					       Int_val(ml_ba_initial_global_length),
					       Data_bigarray_val(ml_ba_initial_data));
    }
  else
    {
      nvec_initial_config=dyn_N_VMake_Serial(Bigarray_val(ml_ba_initial_data)->dim[0],
					     Data_bigarray_val(ml_ba_initial_data));
    }

  if(0==(root_cells=malloc(3*sizeof(value *))))
    {
      aiee("malloc() failure!");
    }

  root_cells[0]=Val_unit;
  root_cells[1]=Val_unit;
  root_cells[2]=Val_unit;

  caml_register_global_root(&root_cells[0]);
  caml_register_global_root(&root_cells[1]);
  caml_register_global_root(&root_cells[2]);

  CAMLlocal3(cvode_block,callbacks_block, callbacks_args);

  callbacks_block = alloc_tuple(5);
  callbacks_args = alloc_tuple(4);

  for(i=0;i<4;i++) {Store_field(callbacks_block,i,Val_unit);}
  for(i=0;i<4;i++) {Store_field(callbacks_args,i,Val_unit);}

  Store_field(callbacks_block,4,Val_bool(is_parallel));
  Store_field(callbacks_block,0,ml_fun_rhs);

  root_cells[0]=callbacks_block;
  root_cells[1]=callbacks_args;
  root_cells[2]=ml_ba_initial_data;

  cvode_block = alloc_final(7, finalize_cvode, sizeof(void*), 10*sizeof(void*));

  if(0==(cvode=dyn_CVodeCreate(CV_BDF,CV_NEWTON))) /* XXX turn these into parameters! */
  {
    if(is_parallel) { dyn_N_VDestroy_Parallel(nvec_initial_config); }
    else { dyn_N_VDestroy_Serial(nvec_initial_config); }
    caml_remove_global_root(&root_cells[0]);
    caml_remove_global_root(&root_cells[1]);
    caml_remove_global_root(&root_cells[2]);
    own_raise_with_string(*caml_named_value(err_exn_name),"CVodeCreate failed!");
  }

  Store_c_field(cvode_block, 1,cvode);
  Store_c_field(cvode_block, 2, Int_val(ml_ba_initial_global_length));
  Store_c_field(cvode_block, 3,nvec_initial_config);
  Store_c_field(cvode_block, 4,0); /* These entries are not used here, they normally
				      hold vector data for petsc's VecRestoreArray() */
  Store_c_field(cvode_block, 5,0);
  Store_c_field(cvode_block, 6,root_cells);

  flag=dyn_CVodeMalloc(cvode,
		       rhs_fn_wrapper,
		       Double_val(ml_initial_time),
		       nvec_initial_config,
		       CV_SS,
		       /* We use scalar relative and absolute error tolerance
			  on all sites.
			  NOTE: we may want to make this an additional
			  parameter later on.
		       */
		       rel_tol,
		       &abs_tol
		       );

  flag2=dyn_CVodeSetFdata(cvode,&root_cells[0]);

  if(flag!=CV_SUCCESS || flag2!=CV_SUCCESS)
    {
      if(is_parallel) {
	dyn_N_VDestroy_Parallel(nvec_initial_config);
      }
      else {
	dyn_N_VDestroy_Serial(nvec_initial_config);
      }

      caml_remove_global_root(&root_cells[0]);
      caml_remove_global_root(&root_cells[1]);
      caml_remove_global_root(&root_cells[2]);

      switch(flag) {
      case CV_MEM_NULL:
      case CV_MEM_FAIL:
	own_raise_with_string(*caml_named_value(err_exn_name),
			      "CVodeMalloc allocation failure!");
	break;
      case CV_ILL_INPUT:
	own_raise_with_string(*caml_named_value(err_exn_name),
			      "CVodeMalloc parameter failure!");
	break;
      case CV_SUCCESS:
	break;
      default: /* also catches flag2 failures (which really should not occur) */
	own_raise_with_string(*caml_named_value(err_exn_name),
			      "CVodeMalloc weird failure!");
      }
    }

  CAMLreturn(cvode_block);
}

/* Note that in principle, we could also change the RHS function
   and similar things here.
*/
CAMLprim value caml_sundials_sp_cvode_reinit(value ml_cvode,
					     value ml_initial_time,
					     value ml_rel_tol,
					     value ml_abs_tol) {
  CAMLparam4(ml_cvode, ml_initial_time,ml_rel_tol,ml_abs_tol);
  void *cvode;
  N_Vector nvec_initial_config;
  double abs_tol;
  int flag;

  sundials_sp_checkinit();

  cvode = (void *) Field(ml_cvode, 1);
  nvec_initial_config = (N_Vector) Field(ml_cvode, 3);

  abs_tol=Double_val(ml_abs_tol);

  if(cvode == NULL)
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "CVode no longer valid!");

  flag = dyn_CVodeReInit(
			 cvode,
			 rhs_fn_wrapper,
			 Double_val(ml_initial_time),
			 nvec_initial_config,
			 CV_SS,
			 Double_val(ml_rel_tol),
			 &abs_tol);

  if (flag != CV_SUCCESS) {
    switch(flag) {
    case CV_MEM_NULL:
    case CV_MEM_FAIL:
      own_raise_with_string(*caml_named_value(err_exn_name),
                            "CVodeReInit allocation failure!");
      break;
    case CV_ILL_INPUT:
      own_raise_with_string(*caml_named_value(err_exn_name),
                            "CVodeReInit parameter failure!");
      break;
    default: /* also catches flag2 failures (which really should not occur) */
      own_raise_with_string(*caml_named_value(err_exn_name),
                            "CVodeReInit unknown error!");
    }
  }

  CAMLreturn(Val_unit);
}

CAMLprim value caml_sundials_sp_cvode_setup_cvspgmr_raw(value ml_cvode,
							value ml_krylov_max,
							value ml_precond_type,
							value ml_preconditioner_setup_fun,
							value ml_preconditioner_solve_fun)
{
  int precond_type,flag;
  void *cvode;
  value *root_cells;

  CAMLparam5(ml_cvode, ml_krylov_max,
	     ml_precond_type,
	     ml_preconditioner_setup_fun,
	     ml_preconditioner_solve_fun);

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"CVode no longer valid!");
    }

  switch(Int_val(ml_precond_type)){
  case 0:
    precond_type=PREC_NONE;
    break;
  case 1:
    precond_type=PREC_LEFT;
    break;
  case 2:
    precond_type=PREC_RIGHT;
    break;
  case 3:
    precond_type=PREC_BOTH;
    break;
  default:
    precond_type=PREC_NONE;
  }

  flag=dyn_CVSpgmr(cvode,precond_type,Int_val(ml_krylov_max));

  if(flag!=CVSPILS_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),"CVode: CVSpgmr failed");
    }

  root_cells=(value *)Field(ml_cvode,6);

  Store_field(root_cells[0],1,ml_preconditioner_setup_fun);
  Store_field(root_cells[0],2,ml_preconditioner_solve_fun);

  flag=dyn_CVSpilsSetPreconditioner(cvode,
				    preconditioner_setup_wrapper,
				    preconditioner_solve_wrapper,
				    root_cells
				    );

  if(flag!=CVSPILS_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVSpilsSetPreconditioner failed");
    }

  CAMLreturn(Val_unit);
}


CAMLprim value caml_sundials_sp_cvode_setup_jacobi_times_vector_raw(value ml_cvode,
								    value ml_jv_fun)
{
  CAMLparam2(ml_cvode, ml_jv_fun);

  void *cvode;
  value *root_cells;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }

  root_cells=(value *)Field(ml_cvode,6);
  Store_field(root_cells[0],3,ml_jv_fun);

  flag=dyn_CVSpilsSetJacTimesVecFn(cvode,jacobian_times_vector_wrapper,
				   root_cells);

  if(flag!=CVSPILS_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVSpilsSetJacTimesVecFn failed!");
    }

  CAMLreturn(Val_unit);
}


CAMLprim value caml_sundials_sp_cvode_set_max_ord(value ml_cvode,
						  value ml_ord)
{
  CAMLparam2(ml_cvode, ml_ord);

  void *cvode;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeSetMaxOrd(cvode,Int_val(ml_ord));

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetMaxOrd failed!");
    }

  CAMLreturn(Val_unit);
}

CAMLprim value caml_sundials_sp_cvode_set_max_num_steps(value ml_cvode,
							value ml_steps)
{
  CAMLparam2(ml_cvode, ml_steps);

  void *cvode;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeSetMaxNumSteps(cvode,Int_val(ml_steps));

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetMaxNumSteps failed!");
    }

  CAMLreturn(Val_unit);
}


CAMLprim value caml_sundials_sp_cvode_set_init_step(value ml_cvode,
						    value ml_step)
{
  CAMLparam2(ml_cvode, ml_step);

  void *cvode;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeSetInitStep(cvode,Double_val(ml_step));

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetInitStep failed!");
    }

  CAMLreturn(Val_unit);
}

CAMLprim value caml_sundials_sp_cvode_set_min_step(value ml_cvode,
						   value ml_step)
{
  CAMLparam2(ml_cvode, ml_step);

  void *cvode;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeSetMinStep(cvode,Double_val(ml_step));

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetMinStep failed!");
    }

  CAMLreturn(Val_unit);
}

CAMLprim value caml_sundials_sp_cvode_set_max_step(value ml_cvode,
						   value ml_step)
{
  CAMLparam2(ml_cvode, ml_step);

  void *cvode;
  int flag;

  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeSetMaxStep(cvode,Double_val(ml_step));

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetMaxStep failed!");
    }

  CAMLreturn(Val_unit);
}




CAMLprim value caml_sundials_sp_cvode_set_tolerances(value ml_cvode,
						     value ml_rel_tol,
						     value ml_abs_tol)
{
  CAMLparam3(ml_cvode, ml_rel_tol, ml_abs_tol);

  void *cvode;
  int flag;
  realtype rel_tol, abs_tol;

  sundials_sp_checkinit();

  cvode = (void *) Field(ml_cvode,1);
  rel_tol = Double_val(ml_rel_tol);
  abs_tol = Double_val(ml_abs_tol);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }

  flag = dyn_CVodeSetTolerances(cvode, CV_SS, rel_tol, & abs_tol);

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeSetTolerances failed!");
    }

  CAMLreturn(Val_unit);
}

CAMLprim value caml_sundials_sp_cvode_get_num_steps(value ml_cvode)
{
  CAMLparam1(ml_cvode);

  void *cvode;
  long nsteps;
  int flag;


  sundials_sp_checkinit();

  cvode=(void *)Field(ml_cvode,1);

  if(0==cvode)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode no longer valid!");
    }


  flag=dyn_CVodeGetNumSteps(cvode,&nsteps);

  if(flag!=CV_SUCCESS)
    {
      own_raise_with_string(*caml_named_value(err_exn_name),
			    "CVode: CVodeGetNumSteps failed!");
    }

  CAMLreturn(copy_double((double)nsteps));
}

/* Enumerate some constants for tuning the behaviour of the function
   My_CVode_Advance_Time */
typedef enum {
  ADVMODE_EXACTTIME = 0x01, /* Take the target time literally (will advance
                               exactly up to that time, not just "near"
			                   to it) */
  ADVMODE_STEP      = 0x02, /* Advance for the given number of steps */
  ADVMODE_TIME      = 0x04  /* Advance until the target time is reached */
} AdvMode;

/* Here we wrap the CVode function which a nicer interface, where we can
   specify whether we would like to advance up to a given time
   or/and number of steps. We also allow to specify if we want to advance
   to exactly the given time or to nearly the specified time.
   The behaviour can be tuned by specifying a value for adv_mode which is
   obtained by or-ing some ADVMODE_* flags. */
static int My_CVode_Advance_Time(void *cvode_mem, N_Vector yout,
                                 AdvMode adv_mode,
                                 realtype *target_time,
                                 int *target_nr_steps,
                                 FILE *err_stream) {
  int use_exacttime = (adv_mode & ADVMODE_EXACTTIME);
  adv_mode = adv_mode & (~ADVMODE_EXACTTIME); /* remove the exacttime flag */
  char *err_msg;
  int flag;

  if (adv_mode == ADVMODE_TIME) {
    /* We just need to check the target time (no step/real-time checks) */
    int itask = (use_exacttime) ? CV_NORMAL_TSTOP : CV_NORMAL;
    dyn_CVodeSetStopTime(cvode_mem, DBL_MAX);
    flag = dyn_CVode(cvode_mem, *target_time, yout, target_time, itask);
    /* ...we now check for 'flag' and report errors... */

  } else if (adv_mode == 0) {
    if (err_stream != NULL)
      fprintf(err_stream,
              "My_CVode_Advance_Time: adv_mode shouldn't be zero!\n");
    return CV_ILL_INPUT;

  } else {
    int itask = (use_exacttime) ? CV_ONE_STEP_TSTOP : CV_ONE_STEP;
    int check_nr_steps = (adv_mode & ADVMODE_STEP) != 0;
    realtype cur_time;
    int cur_nr_steps = 0;

    flag = CV_SUCCESS;
    dyn_CVodeSetStopTime(cvode_mem, *target_time);
    while (!check_nr_steps || cur_nr_steps < *target_nr_steps) {
      flag = dyn_CVode(cvode_mem, *target_time, yout, & cur_time, itask);

      /* when we reach target_time CVode returns flag != CV_SUCCESS */
      if (flag != CV_SUCCESS)
        break;

      ++cur_nr_steps;
    }

    *target_nr_steps += cur_nr_steps;
    *target_time = cur_time;
  }

  /* Check the value returned by the last call to CVode */
  switch(flag) {
  case CV_SUCCESS:
  case CV_TSTOP_RETURN:
    return flag;
  case CV_MEM_NULL: err_msg = "cvode_mem is NULL!"; break;
  case CV_NO_MALLOC: err_msg = "mem not allocated with CVodeMalloc!"; break;
/*
  case CV_ILL_INPUT: err_msg = "Illegal input to CVode!"; break;
  case CV_TOO_CLOSE: err_msg = "initial and final time are too close!"; break;*/
  default:
    if (flag < 0 || 1) {
      if (err_stream != NULL)
        fprintf(err_stream, "My_CVode_Advance_Time: error n. %d\n", flag);
      return CV_ILL_INPUT;

    } else
      return CV_SUCCESS;
  }

  if (err_msg != NULL && err_stream != NULL)
    fprintf(err_stream, "My_CVode_Advance_Time: %s\n", err_msg);

  return flag;
}

/* XXX NOTE: just to make extra sure, we should actually also associate vector length
   information to the cvode and check against the length of ml_vec.

   ...or does sundials actually guard against being given a too short bigarray?
   Presumably so...?
 */
CAMLprim value caml_sundials_sp_cvode_advance_raw_ba(value ml_args)
{
  CAMLparam1(ml_args);

  /* input parameters are:

       0:comm, 1:is_parallel, 2:cvode, 3:vec,
       4:advance_mode, 5:target_time, 6:nr_steps,
       7:verbose
   */

  CAMLlocal3(ml_comm, ml_cvode, ml_vec);

  realtype target_time = Double_val(Field(ml_args, 5));
  int is_parallel = Bool_val(Field(ml_args, 1)),
      advance_mode = Int_val(Field(ml_args, 4)),
      nr_steps = Int_val(Field(ml_args, 6)),
      verbose = Int_val(Field(ml_args, 7)),
      flag;
  void *cvode;
  N_Vector y_out;
  MPI_Comm comm;

  sundials_sp_checkinit();

  /* fprintf(stderr,"DDD Sundials-SP: cvode_advance_raw_ba #1\n");fflush(stderr); */

  ml_comm = Field(ml_args, 0);
  ml_cvode = Field(ml_args, 2);
  ml_vec = Field(ml_args, 3);

  comm = Comm_val(ml_comm);
  cvode = (void *) Field(ml_cvode, 1);

  if (0 == cvode) {
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "CVode no longer valid!");
  }

  if (is_parallel) {
    y_out=dyn_N_VMake_Parallel(comm,
                               Bigarray_val(ml_vec)->dim[0],
                               Field(ml_cvode,2),
                               Data_bigarray_val(ml_vec));
  } else {
    y_out=dyn_N_VMake_Serial(Bigarray_val(ml_vec)->dim[0],
                             Data_bigarray_val(ml_vec));
  }

  flag = My_CVode_Advance_Time(cvode, y_out, advance_mode,
                               & target_time, & nr_steps,
                               (verbose) ? stderr : NULL);

  if(is_parallel) {
    dyn_N_VDestroy_Parallel(y_out);

  } else {
    dyn_N_VDestroy_Serial(y_out);
  }

  /* fprintf(stderr,"DDD Sundials-SP: cvode_advance_raw_ba #5\n");fflush(stderr); */

  CAMLreturn(copy_double(target_time));
}


CAMLprim value caml_sundials_sp_cvode_get_step_info(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  CAMLlocal1(result);

  void *cvode;
  double last_step, current_step, actual_init_step;

  sundials_sp_checkinit();
  cvode=(void*)Field(ml_cvode, 1);
  if(!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  if(CV_SUCCESS!=dyn_CVodeGetLastStep(cvode, &last_step)
  || CV_SUCCESS!=dyn_CVodeGetCurrentStep(cvode, &current_step)
  || CV_SUCCESS!=dyn_CVodeGetActualInitStep(cvode, &actual_init_step))
    own_raise_with_string(*caml_named_value(err_exn_name), "Unable to get last/current/actual init step.");

  result=alloc_tuple(3);
  Store_field(result, 0, copy_double(last_step));
  Store_field(result, 1, copy_double(current_step));
  Store_field(result, 2, copy_double(actual_init_step));
  CAMLreturn(result);
}



CAMLprim value caml_sundials_sp_cvode_get_integrator_stats(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  CAMLlocal1(result);
  void *cvode;

  long int nsteps, nfevals, nlinsetups, netfails;
  int qlast, qcur;
  realtype hinused, hlast, hcur, tcur;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  if (CV_SUCCESS !=
      dyn_CVodeGetIntegratorStats(cvode, & nsteps, & nfevals, & nlinsetups,
                                  & netfails, & qlast, & qcur, & hinused,
                                  & hlast, & hcur, & tcur))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get integrator statistics.");

  result = alloc_tuple(10);
  /* we convert long int --> double and keep int --> int */
  Store_field(result, 0, copy_double((double) nsteps));
  Store_field(result, 1, copy_double((double) nfevals));
  Store_field(result, 2, copy_double((double) nlinsetups));
  Store_field(result, 3, copy_double((double) netfails));
  Store_field(result, 4, copy_double((double) qlast));
  Store_field(result, 5, copy_double((double) qcur));
  Store_field(result, 6, copy_double((double) hinused));
  Store_field(result, 7, copy_double((double) hlast));
  Store_field(result, 8, copy_double((double) hcur));
  Store_field(result, 9, copy_double((double) tcur));
  CAMLreturn(result);
}

CAMLprim value caml_sundials_sp_cvode_get_current_time(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  void *cvode;

  realtype tcur;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "CVode no longer valid!");

  if (CV_SUCCESS != dyn_CVodeGetCurrentTime(cvode, & tcur))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get current time.");

  CAMLreturn(copy_double(tcur));
}

CAMLprim value caml_sundials_sp_cvode_get_nonlinsolv_stats(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  CAMLlocal1(result);
  void *cvode;

  long int nniters, nncfails;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  if (CV_SUCCESS != dyn_CVodeGetNonlinSolvStats(cvode, & nniters, & nncfails))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get non-linear solver statistics.");

  result = alloc_tuple(2);
  /* we convert long int --> double */
  Store_field(result, 0, copy_double((double) nniters));
  Store_field(result, 1, copy_double((double) nncfails));
  CAMLreturn(result);
}

CAMLprim value caml_sundials_sp_cvode_get_tol_scale_factor(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  void *cvode;

  realtype tolsfac;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  if (CV_SUCCESS != dyn_CVodeGetTolScaleFactor(cvode, & tolsfac))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get a suggested tolerance scale factor.");

  CAMLreturn(copy_double(tolsfac));
}

CAMLprim value caml_sundials_sp_cvode_get_num_ord_red(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  void *cvode;

  long int nslred;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  if (CV_SUCCESS != dyn_CVodeGetNumStabLimOrderReds(cvode, & nslred))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get a suggested tolerance scale factor.");

  CAMLreturn(copy_double((double) nslred));
}

CAMLprim value caml_sundials_sp_cvode_get_precond_stats(value ml_cvode)
{
  CAMLparam1(ml_cvode);
  CAMLlocal1(result);
  void *cvode;

  long int npevals, npsolves, nliters, nlcfails, njvevals, nfevalsLS;

  sundials_sp_checkinit();
  cvode = (void*) Field(ml_cvode, 1);
  if (!cvode)
    own_raise_with_string(*caml_named_value(err_exn_name), "CVode no longer valid!");

  /* We don't care if one of these function fails and carry one with
   * the others. If one fails however we throw an exception.
   */
  if (   CV_SUCCESS != dyn_CVSpilsGetNumPrecEvals(cvode, & npevals)
      || CV_SUCCESS != dyn_CVSpilsGetNumPrecSolves(cvode, & npsolves)
      || CV_SUCCESS != dyn_CVSpilsGetNumLinIters(cvode, & nliters)
      || CV_SUCCESS != dyn_CVSpilsGetNumConvFails(cvode, & nlcfails)
      || CV_SUCCESS != dyn_CVSpilsGetNumJtimesEvals(cvode, & njvevals)
      || CV_SUCCESS != dyn_CVSpilsGetNumRhsEvals(cvode, & nfevalsLS))
    own_raise_with_string(*caml_named_value(err_exn_name),
                          "Unable to get preconditioner statistics.");

  result = alloc_tuple(6);
  /* we convert long int --> double */
  Store_field(result, 0, copy_double((double) npevals));
  Store_field(result, 1, copy_double((double) npsolves));
  Store_field(result, 2, copy_double((double) nliters));
  Store_field(result, 3, copy_double((double) nlcfails));
  Store_field(result, 4, copy_double((double) njvevals));
  Store_field(result, 5, copy_double((double) nfevalsLS));
  CAMLreturn(result);
}
